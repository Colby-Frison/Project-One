#include <iostream>
#include <fstream>

using namespace std;

ifstream inputFile("input1.txt");


class SparseRow {
protected:
    int row;   // Row#
    int col;   // Column#
    int value; // We will assume that all our values will be integers
public:
    SparseRow(); // default constructor; row=-1; col=-1; value=0
    SparseRow(int r, int c, int v);
    void display(); // print Row#, Column#, value
    friend ostream& operator<<(ostream& s, const SparseRow& sr);
    int getRow();
    int getCol();
    int getVal();
    void setRow(int r);
    void setCol(int c);
    void setVal(int v);
};

SparseRow::SparseRow() {
    row = -1;
    col = -1;
    value = 0;
}

SparseRow::SparseRow(int r, int c, int v){
    row = r;
    col = c;
    value = v;
}

void SparseRow::display() {
    cout << getRow() << ", " << getCol() << ", " << getVal() << endl;
}

ostream& operator<<(ostream& s, const SparseRow& sr) {
    s << sr.row << ", " << sr.col << ", " << sr.value;
    return s;
}

void SparseRow::setRow(int r) {
    row = r;}

void SparseRow::setCol(int c) {
    col = c;
}

void SparseRow::setVal(int v) {
    value = v;
}

int SparseRow::getRow() {
    return row;
}

int SparseRow::getCol() {
    return col;
}

int SparseRow::getVal() {
    return value;
}

class SparseMatrix {
protected:
    int noRows;         // Number of rows of the original matrix
    int noCols;         // Number of columns of the original matrix
    int commonValue;    // read from input
    int noNonSparseValues;
    SparseRow* myMatrix; // Array
public:
    SparseMatrix();
    SparseMatrix(int n, int m, int cv);
    SparseMatrix(int n, int m, int cv, int noNSV);
    ~SparseMatrix(); // Destructor to free memory
    SparseMatrix* Transpose(); // Matrix Transpose
    SparseMatrix* Multiply(SparseMatrix& M);
    SparseMatrix* Add(SparseMatrix& M);
    friend ostream& operator<<(ostream& s, const SparseMatrix& sm);
    void displayMatrix(); // Display the matrix in its original format
    int getRows();
    int getCols();
};

int SparseMatrix::getCols(){
    return noCols;
}

int SparseMatrix::getRows(){
    return noRows;
}

SparseMatrix::SparseMatrix() {
    noRows = -1;
    noCols = -1;
    commonValue = 0;
    noNonSparseValues = 0;
    myMatrix = nullptr;
}

SparseMatrix::SparseMatrix(int n, int m, int cv, int noNSV) {
    this->noRows = n;  // Correct initialization
    this->noCols = m;
    commonValue = cv;
    noNonSparseValues = noNSV;

    int temp = 0;
    int nonSparseCount = 0;

    for (int i = 0; i < noRows; i++) {
        for (int j = 0; j < noCols; j++) {
            inputFile >> temp;
            if (temp != commonValue) {
                myMatrix[nonSparseCount++] = SparseRow(i, j, temp);
            }
        }
    }
}
/*
SparseMatrix::~SparseMatrix() {
    delete[] myMatrix;
}
*/
SparseMatrix* SparseMatrix::Transpose() {
    // Implement the transpose logic here
    return new SparseMatrix(); // Placeholder return
}

SparseMatrix* SparseMatrix::Multiply(SparseMatrix& M) {
    // Implement the multiplication logic here
    return new SparseMatrix(); // Placeholder return
}

SparseMatrix* SparseMatrix::Add(SparseMatrix& M) {
    // Implement the addition logic here
    return new SparseMatrix(); // Placeholder return
}

ostream& operator<<(ostream& s, const SparseMatrix& sm) {
    for (int i = 0; i < sm.noNonSparseValues; i++) {
        s << sm.myMatrix[i] << endl;
    }
    return s;
}

void SparseMatrix::displayMatrix() {
    for(int i = 0; i < noNonSparseValues; i++){
        cout << "test";
        //cout << myMatrix[i];
    }
    cout << endl;
}

int main() {
    cout << "test";

      // Open file

    int n, m, cv, noNSV;
    //SparseMatrix* temp;

    inputFile >> n >> m >> cv >> noNSV;
    cout << n << m << cv << noNSV;
    SparseMatrix* firstOne = new SparseMatrix(n, m, cv, noNSV);

    inputFile >> n >> m >> cv >> noNSV;
    SparseMatrix* secondOne = new SparseMatrix(n, m, cv, noNSV);
    // Populate secondOne with data

    cout << "First one in sparse matrix format" << endl;
    firstOne->displayMatrix();
    cout << "After transpose" << endl;

    cout << "First one in matrix format" << endl;

    cout << "Second one in sparse matrix format" << endl;
    secondOne->displayMatrix();
    cout << "After transpose" << endl;

    cout << "Second one in matrix format" << endl;

    cout << "Matrix addition result" << endl;

    cout << "Matrix multiplication result" << endl;

    /*

    cout << "First one in matrix format" << endl;
    firstOne->displayMatrix();
    cout << "First one in sparse matrix format" << endl;
    cout << *firstOne;
    cout << "Second one in matrix format" << endl;
    secondOne->displayMatrix();
    cout << "Second one in sparse matrix format" << endl;
    cout << *secondOne;
    cout << "Transpose of the first one in matrix" << endl;
    cout << *(firstOne->Transpose());
    cout << "Matrix Addition Result" << endl;
    temp = firstOne->Add(*secondOne);
    cout << *temp;
    temp->displayMatrix();
    cout << "Matrix Multiplication Result" << endl;
    temp = firstOne->Multiply(*secondOne);
    cout << *temp;
    temp->displayMatrix();

    */

    return 0;
}
